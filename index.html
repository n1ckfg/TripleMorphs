<!DOCTYPE html>
<html>

	<head>
		<title>Hello</title>
		<style>
			body {
				background: gray;
				margin: 0px;
			}
		</style>
		<script src="https://fox-gieg.com/js/libraries/threejs/122/three.min.js"></script>
	</head> 

	<body>
		<script>
			"use strict";

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
			camera.position.set(0, 0, 100);
			camera.lookAt(0, 0, 0);

			const clock = new THREE.Clock();

			const scene = new THREE.Scene();

			const material = new THREE.LineBasicMaterial({ color: 0x00ffff });

			function drawLine(points) {
				for (let i=0; i<points.length; i++ ) {
					points[i].multiplyScalar(10);
				}
				let geo = new THREE.BufferGeometry().setFromPoints(points);
				let line = new THREE.Line(geo, material);
				scene.add(line);
			}

			function drawLines(lines) {
				for (let line of lines) {
					drawLine(line);
				}
			}

			/*
			const points1 = [];
			points1.push(new THREE.Vector3(- 10, 0, 0));
			points1.push(new THREE.Vector3(0, 10, 0));
			points1.push(new THREE.Vector3(10, 0, 0));

			const geo1 = new THREE.BufferGeometry().setFromPoints(points1);
			// Note that lines are drawn between each consecutive pair of vertices, but not between the first and last (the line is not closed.)

			// Now that we have points for two lines and a material, we can put them together to form a line.

			const line1 = new THREE.Line(geo1, mat1);
			// All that's left is to add it to the scene and call render.

			scene.add(line1);

			// ~ ~ ~ ~ ~

			const mat2 = new THREE.LineBasicMaterial({
			color: 0x00ffff
			});

			let v = 13;

			const points2 = [];
			points2.push(new THREE.Vector3(-v, 0, 0));
			points2.push(new THREE.Vector3(0, v, 0));
			points2.push(new THREE.Vector3(v, 0, 0));

			const geo2 = new THREE.BufferGeometry().setFromPoints(points2);

			const line2 = new THREE.Line(geo2, mat2);
			scene.add(line2);

			function render() {
			renderer.render(scene, camera);
			v++;
			requestAnimationFrame(render);
			}	 
					
			render();
			*/

			let lexicon = "Ff+-<>(.".split("");

			let pop = [];
			let pop_size = 16;
			let mutability = 0.5;

			// get number of columns/rows from population size:
			let cols = Math.ceil(Math.sqrt(pop_size));
			let rows = cols;

			let cmds;

			function create(size) {
				let geno = [];
				for (let i=0; i<size; i++) {
					geno.push(lexicon[parseInt(Math.random() * lexicon.length)]);	
				}
				return geno;
			}

			function reset() {
				pop = [];
				for (let i=0; i<pop_size; i++) {
					pop[i] = {
						cmds: create(40),
					}
					console.log(i + ". " + pop[i].cmds);
					//write(pop[i].cmds.join(""))
				}

				draw();
			}

			function turtledraw(t, cmds) {
				let lines = [];
				let now = clock.getElapsedTime();

				for (let i=0; i<cmds.length; i++) {
					let cmd = cmds[i];
					if (cmd == "F") {
						// move forward, drawing a line:
						lines.push(t.pos.clone());	
						t.pos.add(t.dir); // move
						lines.push(t.pos.clone());
					} else if (cmd == "f") {
						// move forward, drawing a line:
						lines.push(t.pos.clone());	
						t.pos.add(t.dir.clone().multiplyScalar(0.5)); // move
						lines.push(t.pos.clone());
					} else if (cmd == "+") {
						// rotate 90 degrees:
						//t.dir.rotate(t.angle * Math.sin(now));
					} else if (cmd == "-") {
						// rotate 90 degrees:
						//t.dir.rotate(-t.angle * Math.sin(now));
					} else if (cmd == "<") {
						t.angle *= 2;
					} else if (cmd == ">") {
						t.angle /= 2;
					} else if (cmd == "(") {
						// spawn a copy of the turtle:
						let t1 = {
							pos: t.pos.clone(),
							dir: t.dir.clone(),
							angle: -t.angle
						}
						let morelines = turtledraw(t1, cmds.slice(i+1));
						lines = lines.concat(morelines);
					}
				}

				return lines;
			}

			function regenerate(chosen) {
				let newpop = [];
				let parent = pop[chosen];
				
				for (let i=0; i<pop_size; i++) {
					let child = {
						cmds: []
					}
					
					for (let j=0; j<parent.cmds.length; j++) {
						if (Math.random() < mutability / parent.cmds.length) {
							child.cmds[j] = lexicon[parseInt(Math.random() * lexicon.length)];
						} else {
							child.cmds[j] = parent.cmds[j];
						}
					}
					newpop[i] = child;
				}
				pop = newpop;
			}

			function draw() {
				// clear scene
				scene.remove.apply(scene, scene.children);

				for (let i=0; i<pop.length; i++) {
					// get row/col from population index `i`
					let row = Math.floor(i/cols);
					let col = i % cols;
					//draw2D.push().scale(1/cols).translate(row, col)
					
					let turtle = {
						pos: new THREE.Vector3(0.5, 0.9, 0),
						dir: new THREE.Vector3(0, -0.1, 0),
						angle: Math.PI/4
					}

					let lines = turtledraw(turtle, pop[i].cmds);
					drawLines(lines);
					
					//draw2D.pop()
				}

				/*
				// test
				let points = []
				for (let i=0; i<100; i++) {
					let x = Math.random() - 0.5;
					let y = Math.random() - 0.5;
					let z = 0;
					points.push(new THREE.Vector3(x, y, z).multiplyScalar(50));
				}

				drawLine(points);
				*/

				renderer.render(scene, camera);
				requestAnimationFrame(draw);
			}

			/*
			function mouse(kind, pt) {
				if (kind == "down") {
					// scale point up to grid size:
					let col = Math.floor(pt[0] * cols);
					let row = Math.floor(pt[1] * cols);
					let index = row + col*cols;

					// now create a new generation with `pop[index]`...
					regenerate(index);
				}
			}
			*/

			window.onload = reset;
		</script>
	</body>

</html>
